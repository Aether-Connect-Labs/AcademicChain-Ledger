{
  "name": "Orquestador Multichain AcademicChain",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "emitir-multichain",
        "options": {}
      },
      "name": "Webhook_Entrada",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [0, 0]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.headers['x-acl-auth-key']}}",
              "operation": "equal",
              "value2": "={{$env.ACL_AUTH_KEY}}"
            }
          ]
        }
      },
      "name": "Auth_Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [200, 0]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\"error\": \"Unauthorized\"}",
        "options": { "responseCode": 401 }
      },
      "name": "Reject",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [200, 200]
    },
    {
      "parameters": {
        "jsCode": "const q = $json.query || {}; const b = $json.body || {}; const docHash = String(q.documentHash || b.documentHash || b.uniqueHash || '').trim(); const studentName = String(q.studentName || b.studentName || '').trim(); let plan = String(q.plan || b.plan || '').toLowerCase().trim(); const uniqueHash = docHash || ('hash-'+Date.now()); const normalizePlan = (p)=>{ if(['triple','3','enterprise','ent','empresarial'].includes(p)) return 'triple'; if(['dual','2','professional','pro','profesional'].includes(p)) return 'dual'; if(['base','1','basic','esencial','essential'].includes(p)) return 'base'; return 'base'; }; const planNormalized = normalizePlan(plan); return { json: { uniqueHash, studentName, plan: planNormalized, originalPlan: plan || 'auto' } };"
      },
      "name": "Normalize Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 0]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            { "value1": "={{$json.plan}}", "operation": "equal", "value2": "triple" }
          ]
        }
      },
      "name": "Is Triple",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [600, -120]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            { "value1": "={{$json.plan}}", "operation": "equal", "value2": "dual" }
          ]
        }
      },
      "name": "Is Dual",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [600, 120]
    },
    {
      "parameters": {
        "jsCode": "const tx = '0.0.' + (Math.floor(Math.random()*9000000)+1000000) + '@' + Date.now(); return { json: { ...$json, hederaTx: tx } };"
      },
      "name": "Hedera Issue",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [820, -200]
    },
    {
      "parameters": {
        "jsCode": "const x = 'xrpl-' + Math.random().toString(16).slice(2) + '-' + Date.now(); return { json: { ...$json, xrpTxHash: x } };"
      },
      "name": "XRP_Emit",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [820, 0]
    },
    {
      "parameters": {
        "jsCode": "const a = 'algo-' + Math.random().toString(16).slice(2) + '-' + Date.now(); return { json: { ...$json, algoTxId: a } };"
      },
      "name": "Algorand_Emit",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [820, 200]
    },
    {
      "parameters": { "mode": "combine", "combination": "mergeByPosition" },
      "name": "Unir_Hashes",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 1,
      "position": [1040, 0]
    },
    {
      "parameters": {
        "jsCode": "const items = $items(); let h=null,x=null,a=null,base=null; for (const it of items) { const j = it.json||{}; if (j.hederaTx) h=j.hederaTx; if (j.xrpTxHash) x=j.xrpTxHash; if (j.algoTxId) a=j.algoTxId; if (j.uniqueHash && !base) base=j; } const out = { uniqueHash: base?.uniqueHash || $json.uniqueHash, studentName: base?.studentName || $json.studentName, externalProofs: {} }; if (h) out.externalProofs.hederaTx = h; if (x) out.externalProofs.xrpTxHash = x; if (a) out.externalProofs.algoTxId = a; out.hash_hedera = h || null; out.hash_xrp = x || null; out.hash_algo = a || null; out.updatedAt = new Date().toISOString(); if (!out.createdAt) out.createdAt = out.updatedAt; return { json: out };"
      },
      "name": "Consolidate Proofs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1240, 0]
    },
    {
      "parameters": {
        "operation": "update",
        "collection": "credentials",
        "query": "={\"uniqueHash\": {{$node[\"Webhook_Entrada\"].json.query.documentHash || $json.uniqueHash}} }",
        "fieldsUi": {
          "field": [
            { "fieldName": "uniqueHash", "fieldValue": "={{$json.uniqueHash}}" },
            { "fieldName": "studentName", "fieldValue": "={{$json.studentName}}" },
            { "fieldName": "externalProofs", "fieldValue": "={{$json.externalProofs}}" },
            { "fieldName": "externalProofs.xrpTxHash", "fieldValue": "={{$json.hash_xrp}}" },
            { "fieldName": "externalProofs.hederaTx", "fieldValue": "={{$json.hash_hedera}}" },
            { "fieldName": "externalProofs.algoTxId", "fieldValue": "={{$json.hash_algo}}" },
            { "fieldName": "updatedAt", "fieldValue": "={{$json.updatedAt}}" }
          ]
        },
        "options": { "upsert": true }
      },
      "name": "Guardar_MongoDB_MultiChain",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1,
      "position": [1440, 0],
      "credentials": {
        "mongoDb": { "id": "mongo_cred", "name": "MongoDB Local" }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{ \"success\": true, \"data\": {{$json}} }",
        "options": {}
      },
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1640, 0]
    }
  ],
  "connections": {
    "Webhook_Entrada": { "main": [[{ "node": "Auth_Check", "type": "main", "index": 0 }]] },
    "Auth_Check": {
      "main": [
        [{ "node": "Normalize Input", "type": "main", "index": 0 }],
        [{ "node": "Reject", "type": "main", "index": 0 }]
      ]
    },
    "Normalize Input": {
      "main": [
        [{ "node": "Is Triple", "type": "main", "index": 0 }]
      ]
    },
    "Is Triple": {
      "main": [
        [
          { "node": "Hedera Issue", "type": "main", "index": 0 },
          { "node": "XRP_Emit", "type": "main", "index": 0 },
          { "node": "Algorand_Emit", "type": "main", "index": 0 }
        ],
        [{ "node": "Is Dual", "type": "main", "index": 0 }]
      ]
    },
    "Is Dual": {
      "main": [
        [{ "node": "Hedera Issue", "type": "main", "index": 0 }, { "node": "XRP_Emit", "type": "main", "index": 0 }],
        [{ "node": "Hedera Issue", "type": "main", "index": 0 }]
      ]
    },
    "Hedera Issue": { "main": [[{ "node": "Unir_Hashes", "type": "main", "index": 0 }]] },
    "XRP_Emit": { "main": [[{ "node": "Unir_Hashes", "type": "main", "index": 1 }]] },
    "Algorand_Emit": { "main": [[{ "node": "Unir_Hashes", "type": "main", "index": 2 }]] },
    "Unir_Hashes": { "main": [[{ "node": "Consolidate Proofs", "type": "main", "index": 0 }]] },
    "Consolidate Proofs": { "main": [[{ "node": "Guardar_MongoDB_MultiChain", "type": "main", "index": 0 }]] },
    "Guardar_MongoDB_MultiChain": { "main": [[{ "node": "Respond", "type": "main", "index": 0 }]] }
  }
}
